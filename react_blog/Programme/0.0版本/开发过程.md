## 搭建基础环境

本来想尝试不用脚手架从0开始搭建一个react项目，但是发现需要配置的webpack内容有点多，于是就使用脚手架了···

```
npx create-react-app react_blog
```

### webpack配置

做webpack配置：暴露项目的webpack.config.js文件，直接在该文件中进行修改配置（之前会有prod和dev两个环境的相关配置，但是新版run eject之后只存在一个webpack.config.js文件）

但是这样过于麻烦，因此通过`react-app-rewired`来配置webpack.config.js，这种配置方式无需生成更多额外的文件，同时更简单可控

```
yarn add react-app-rewired customize-cra
```

更改项目package.json文件

```json
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
	// 改为
  "scripts": {
    "start": "react-app-rewired start",
    "build": "react-app-rewired build",
    "test": "react-app-rewired test",
    "eject": "react-app-rewired eject"
  },
```

在项目根目录创建一个 `config-overrides.js` 用于修改默认配置

```jsx
const { override } = require('customize-cra');		// // 解构
module.exports = override(
	A(),
    B(),
    ...		// 各种配置项一起写在这里
)
```

#### less

使项目能识别less文件以代替css

```
yarn add less less-loader
```

```jsx
const { override, addLessLoader } = require('customize-cra');
module.exports = override(
	addLessLoader({
		javascriptEnabled: true,
	}),
)
```

**遇到的坑：**

安装less-loader时，发现6.0.1的版本无法正常使用，安装回5.0.0版本就可以了，目前还没找到最新版的可用的方法（或者可以尝试暴漏webpack在webpack里直接修改）

```
yarn add less-loader@5.0.0
```

#### 装饰器

使项目能使用装饰器

```
yarn add @babel/plugin-proposal-decorators	// 安装修饰符插件
```

```jsx
const { override, addDecoratorsLegacy } = require('customize-cra')		
module.exports = override(
    addDecoratorsLegacy()   // 配置适配器模式方法 这里可以传很多方法
)
```



---

### 设计路由

先简单设计几个路由页面，后续再补充

<img src="http://m.qpic.cn/psc?/V13Q7pAC4ZWKBC/ZOCeIbt3t.P7YdMG6dQVpEirjVA6FzCjFIplld0e9i8Ezb.5nlaok3u0nDrzlBRX0Rki.tn4U9L7Kn30mwIobA!!/b&bo=ygGBAcoBgQEDCSw!&rf=viewer_4" style="margin:0">

根据路由划分组件

<img src="http://m.qpic.cn/psc?/V13Q7pAC4ZWKBC/ZOCeIbt3t.P7YdMG6dQVpBn3X6sb2l0ax0HN.ytyrOlPvMa3lGakfgCd0GBAbZvn.7CYI1QYrpg4D057BAjBqA!!/b&bo=1AC6AdQAugEDCSw!&rf=viewer_4" style="margin:0">

----

#### 实现按需加载页面

在页面文件夹views下建立`index.js`用于导出页面给路由管理，其中为了实现按需加载优化性能需要下载安装`react-loadable`

```
yarn add babel-loader
```

```
React 项目打包时，如果不进行异步组件的处理，那么所有页面所需要的 js 都在同一文件中（bundle.js），整个js文件很大，从而导致首屏加载时间过长，这时应对代码进行分割，按需加载，将js 拆分成若干个chunk.js,用到就加载，react-loadable就可以很好地解决这个问题
```

**懒加载原理：**

即使用的时候再导入

如：下面代码在渲染页面结束还没点击按钮的时候，打印`test.js`，表明了`test.js`文件即使在没有使用的时候，也会进行加载

```jsx
// index.html
<button id='btn'>按钮</button>

// index.js
import {add} form 'test.js'
document.getElementById().onclick() = function() {
	console.log(add(1,2))
}

// test.js
console.log('加载了test.js')
export function add (x, y) {
    return x + y
} 

```

使用懒加载（使用的时候再导入，且导入一次会写入缓存，之后不会再重复导入，因此无需担心每调用一次函数都导入一次）

```jsx
document.getElementById().onclick() = function() {
    // 懒加载
	import('./test')
    	.then(() => {
			console.log(add(1,2))        
    	})
}
```

**react-loadable实现原理**

```jsx
import React, { Component } from 'react';

const Loadble = ({
    loader,				// 要加载的组件，这是传入的是一个Promise方法，为`import('...')`
    loading: Loading    // 组件不能小写开头，可以转一下，使用一个loading组件的原因是防止异步加载大文件时耗时过长空屏很尴尬，因此显示一点什么东西给别人看
}) => {
    return class Loader extends Component {
        state = {
            LoaderComponent: null
        }
        
        componentDidMount() {
            // import('...')
            loader()
                .then((resp)=>{
                    this.setState({
                        LoaderComponent:resp.default
                    })
                })
        }
        render() {
            const {
                LoaderComponent
            } = this.state  // 解构
            
            return (
                // 如果组件尚未加载完成，显示loading组件，加载完成后显示加载组件
                LoaderComponent
                ?
                <LoaderComponent/>
                :
                <Loading/>
            );
        }
    }
        
}
export defalut Loadble
```

然后就可以用它来封装一个组件使其变成高阶组件

```jsx
import Loading from './Loading'

HighComponent =  hLoadble({
    loader: () => import(./Component),
    loading: Loading
})
...
redner( <HighComponent/> )
```

当然如果不想了解其中的原理可以把上面都当废话，直接用就是了，最终页面总管理页内容为：

```jsx
// /src/views/index.js
import {Loading} from '../components'
import Loadable from 'react-loadable'

// 封装成更方便的函数，不用多次写loading了
const loaderFun = (loader, loading = Loading) => {
    return Loadable({
        loader,
        loading
    })
}

const NotFound = loaderFun(() => import('NotFound'))
const AboutBlog = loaderFun(() => import('./AboutBlog'))
const BlogArticle = loaderFun(() => import('BlogArticle'))
const Essay = loaderFun(() => import('Essay'))
const MessageBoard = loaderFun(() => import('MessageBoard'))
const Other = loaderFun(() => import('Other'))


export { 
    NotFound,
    AboutBlog,
    BlogArticle,
    Essay,
    MessageBoard,
    Other
}
```

----

#### 实现路由

创建一个统一管理路由并导出的js文件，先集中在一起，后续再看看要不要分开

```jsx
// /src/routers/index.js
// 统一管理路由并导出
import {
    Home,
    NotFound,
    AboutBlog,
    BlogArticle,
    Essay,
    MessageBoard,
    Other
} from '../views'

export const routers = [
    {
        pathname: '/',
        viewCompoment:Home,
        exact:true
    },{
        pathname: '/404',
        viewCompoment: NotFound
    },{
        pathname: '/aboutBlog',
        viewCompoment: AboutBlog,
        excat:true
    },{
        pathname: '/blogArticle',
        viewCompoment: BlogArticle,
        exact:true
    },{
        pathname: '/essay',
        viewCompoment: Essay,
        exact:true
    },{
        pathname: '/messageBoard',
        viewCompoment: MessageBoard,
        exact:true
    },{
        pathname: '/other',
        viewCompoment: Other,
        exact:true
    }
]

```

使用`react-router-dom`来配置路由

```
yarn add react-router-dom
```

配置index.js和app.js路由

```jsx
// /index.js
import React, { Fragment } from 'react'
import { render } from 'react-dom'

import {BrowserRouter as Router, Route} from 'react-router-dom'

import App from './App'

render(
    <Fragment>
        {/* 访问域名立即渲染App组件 */}
        <Router>    
            <Route path='/' render={(routerProps) =>{
                    return <App {...routerProps}  />     // 传递路由api
            }} /> 
        
        </Router>     
    </Fragment>,
    document.querySelector('#root')
)
```

```jsx
import React,{Component, Fragment} from 'react'

import {Route, Switch, Redirect} from 'react-router-dom'

import {routers} from './routers'

import './App.less'

export default class App extends Component {
    
    render() {
        return (
            <Fragment>
                <Switch>
                    {
                        routers.map(router => {
                            return <Route
                                key = {router.pathname}
                                path = {router.pathname}
                                exact = {router.exact}
                                render = {(routerProps) => {
                                    return <router.viewCompoment {...routerProps} />
                                
                                }}
                            />
                        })
                    }
                    <Redirect to='/404' />      {/* 搜寻不到路由时跳转404 */}
                    
                </Switch>

            </Fragment>
        )
    }
}
```











