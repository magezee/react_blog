## 搭建基础环境

本来想尝试不用脚手架从0开始搭建一个react项目，但是发现需要配置的webpack内容有点多，于是就使用脚手架了···

```
npx create-react-app react_blog
```

### webpack配置

做webpack配置：暴露项目的webpack.config.js文件，直接在该文件中进行修改配置（之前会有prod和dev两个环境的相关配置，但是新版run eject之后只存在一个webpack.config.js文件）

但是这样过于麻烦，因此通过`react-app-rewired`来配置webpack.config.js，这种配置方式无需生成更多额外的文件，同时更简单可控

```
yarn add react-app-rewired customize-cra
```

更改项目package.json文件

```json
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
	// 改为
  "scripts": {
    "start": "react-app-rewired start",
    "build": "react-app-rewired build",
    "test": "react-app-rewired test",
    "eject": "react-app-rewired eject"
  },
```

在项目根目录创建一个 `config-overrides.js` 用于修改默认配置

```jsx
const { override } = require('customize-cra');		// // 解构
module.exports = override(
	A(),
    B(),
    ...		// 各种配置项一起写在这里
)
```

#### less

使项目能识别less文件以代替css

```
yarn add less less-loader
```

```jsx
const { override, addLessLoader } = require('customize-cra');
module.exports = override(
	addLessLoader({
		javascriptEnabled: true,
	}),
)
```

**遇到的坑：**

安装less-loader时，发现6.0.1的版本无法正常使用，安装回5.0.0版本就可以了，目前还没找到最新版的可用的方法（或者可以尝试暴漏webpack在webpack里直接修改）

```
yarn add less-loader@5.0.0
```

#### 装饰器

使项目能使用装饰器

```
yarn add @babel/plugin-proposal-decorators	// 安装修饰符插件
```

```jsx
const { override, addDecoratorsLegacy } = require('customize-cra')		
module.exports = override(
    addDecoratorsLegacy()   // 配置适配器模式方法 这里可以传很多方法
)
```



---

### 设计路由

先简单设计几个路由页面，后续再补充

<img src="http://m.qpic.cn/psc?/V13Q7pAC4ZWKBC/ZOCeIbt3t.P7YdMG6dQVpEirjVA6FzCjFIplld0e9i8Ezb.5nlaok3u0nDrzlBRX0Rki.tn4U9L7Kn30mwIobA!!/b&bo=ygGBAcoBgQEDCSw!&rf=viewer_4" style="margin:0">

根据路由划分组件

<img src="http://m.qpic.cn/psc?/V13Q7pAC4ZWKBC/ZOCeIbt3t.P7YdMG6dQVpBn3X6sb2l0ax0HN.ytyrOlPvMa3lGakfgCd0GBAbZvn.7CYI1QYrpg4D057BAjBqA!!/b&bo=1AC6AdQAugEDCSw!&rf=viewer_4" style="margin:0">

----

#### 实现按需加载页面

在页面文件夹views下建立`index.js`用于导出页面给路由管理，其中为了实现按需加载优化性能需要下载安装`react-loadable`

```
yarn add babel-loader
```

```
React 项目打包时，如果不进行异步组件的处理，那么所有页面所需要的 js 都在同一文件中（bundle.js），整个js文件很大，从而导致首屏加载时间过长，这时应对代码进行分割，按需加载，将js 拆分成若干个chunk.js,用到就加载，react-loadable就可以很好地解决这个问题
```

**懒加载原理：**

即使用的时候再导入

如：下面代码在渲染页面结束还没点击按钮的时候，打印`test.js`，表明了`test.js`文件即使在没有使用的时候，也会进行加载

```jsx
// index.html
<button id='btn'>按钮</button>

// index.js
import {add} form 'test.js'
document.getElementById().onclick() = function() {
	console.log(add(1,2))
}

// test.js
console.log('加载了test.js')
export function add (x, y) {
    return x + y
} 

```

使用懒加载（使用的时候再导入，且导入一次会写入缓存，之后不会再重复导入，因此无需担心每调用一次函数都导入一次）

```jsx
document.getElementById().onclick() = function() {
    // 懒加载
	import('./test')
    	.then(() => {
			console.log(add(1,2))        
    	})
}
```

**react-loadable实现原理**

```jsx
import React, { Component } from 'react';

const Loadble = ({
    loader,				// 要加载的组件，这是传入的是一个Promise方法，为`import('...')`
    loading: Loading    // 组件不能小写开头，可以转一下，使用一个loading组件的原因是防止异步加载大文件时耗时过长空屏很尴尬，因此显示一点什么东西给别人看
}) => {
    return class Loader extends Component {
        state = {
            LoaderComponent: null
        }
        
        componentDidMount() {
            // import('...')
            loader()
                .then((resp)=>{
                    this.setState({
                        LoaderComponent:resp.default
                    })
                })
        }
        render() {
            const {
                LoaderComponent
            } = this.state  // 解构
            
            return (
                // 如果组件尚未加载完成，显示loading组件，加载完成后显示加载组件
                LoaderComponent
                ?
                <LoaderComponent/>
                :
                <Loading/>
            );
        }
    }
        
}
export defalut Loadble
```

然后就可以用它来封装一个组件使其变成高阶组件

```jsx
import Loading from './Loading'

HighComponent =  hLoadble({
    loader: () => import(./Component),
    loading: Loading
})
...
redner( <HighComponent/> )
```

当然如果不想了解其中的原理可以把上面都当废话，直接用就是了，最终页面总管理页内容为：

```jsx
// /src/views/index.js
import {Loading} from '../components'
import Loadable from 'react-loadable'

// 封装成更方便的函数，不用多次写loading了
const loaderFun = (loader, loading = Loading) => {
    return Loadable({
        loader,
        loading
    })
}

const NotFound = loaderFun(() => import('NotFound'))
const AboutBlog = loaderFun(() => import('./AboutBlog'))
const BlogArticle = loaderFun(() => import('BlogArticle'))
const Essay = loaderFun(() => import('Essay'))
const MessageBoard = loaderFun(() => import('MessageBoard'))
const Other = loaderFun(() => import('Other'))


export { 
    NotFound,
    AboutBlog,
    BlogArticle,
    Essay,
    MessageBoard,
    Other
}
```

----

#### 实现路由

创建一个统一管理路由并导出的js文件，先集中在一起，后续再看看要不要分开

```jsx
// /src/routers/index.js
// 统一管理路由并导出
import {
    Home,
    NotFound,
    AboutBlog,
    BlogArticle,
    Essay,
    MessageBoard,
    Other
} from '../views'

export const routers = [
    {
        pathname: '/',
        viewCompoment:Home,
        exact:true
    },{
        pathname: '/404',
        viewCompoment: NotFound
    },{
        pathname: '/aboutBlog',
        viewCompoment: AboutBlog,
        excat:true
    },{
        pathname: '/blogArticle',
        viewCompoment: BlogArticle,
        exact:true
    },{
        pathname: '/essay',
        viewCompoment: Essay,
        exact:true
    },{
        pathname: '/messageBoard',
        viewCompoment: MessageBoard,
        exact:true
    },{
        pathname: '/other',
        viewCompoment: Other,
        exact:true
    }
]

```

使用`react-router-dom`来配置路由

```
yarn add react-router-dom
```

配置index.js和app.js路由

```jsx
// /index.js
import React, { Fragment } from 'react'
import { render } from 'react-dom'

import {BrowserRouter as Router, Route} from 'react-router-dom'

import App from './App'

render(
    <Fragment>
        {/* 访问域名立即渲染App组件 */}
        <Router>    
            <Route path='/' render={(routerProps) =>{
                    return <App {...routerProps}  />     // 传递路由api
            }} /> 
        
        </Router>     
    </Fragment>,
    document.querySelector('#root')
)
```

```jsx
import React,{Component, Fragment} from 'react'

import {Route, Switch, Redirect} from 'react-router-dom'

import {routers} from './routers'

import './App.less'

export default class App extends Component {
    
    render() {
        return (
            <Fragment>
                <Switch>
                    {
                        routers.map(router => {
                            return <Route
                                key = {router.pathname}
                                path = {router.pathname}
                                exact = {router.exact}
                                render = {(routerProps) => {
                                    return <router.viewCompoment {...routerProps} />
                                
                                }}
                            />
                        })
                    }
                    <Redirect to='/404' />      {/* 搜寻不到路由时跳转404 */}
                    
                </Switch>

            </Fragment>
        )
    }
}
```

### 设计主页

#### 确定方案

先随便画一下主页

```
不错的在线作图网站（可免费）：https://www.processon.com/
```

**方案一：**

<img src="http://a1.qpic.cn/psc?/V13Q7pAC4ZWKBC/ZOCeIbt3t.P7YdMG6dQVpFLahNyMclOaukaKtKlIYy2HFN5fiUYfJw7AdgecUhTxkE.b9yJKuC2R8SKgdJeVuA!!/b&ek=1&kp=1&pt=0&bo=EgSVAhIElQIDGTw!&tl=1&vuin=756591143&tm=1589767200&sce=60-2-2&rf=viewer_4" style="margin:0">

**方案二：**

<img src="http://m.qpic.cn/psc?/V13Q7pAC4ZWKBC/ZOCeIbt3t.P7YdMG6dQVpPrAqeL0qOxVN*L7wmPsNsgr7L8MFnX5LVZZzcb47Zmd2426e8ia1BL0JKUVNTk2Tg!!/b&bo=HQS.Ah0EvgIDCSw!&rf=viewer_4" style="margin:0">

总觉得方案一好像少了点什么，没有将大体定住的感觉，因此先采用方案二看看效果

----

#### 设计区域

**决定公共区域和路由变化区域**

除了主内容区跟随着路由跳转而发生变化外，其他都算是公共区域，即路由发生跳转，渲染页面发生变化时，它也会继续存在

一个简单可行的思路：将公共区域的单独抽成各个组件，然后再每个页面渲染时都渲染一遍这些公共组件

不过这种方法太过于累赘，于是准备将顶，左，右部分合并做成一个公共组件`Common`，然后在`app.js`内进行渲染

未来肯定是要再将这些div换成一个单独的一个组件的，但是目前没想到怎么整于是先用div代替这些组件

```jsx
// /src/components/Common/index.js
import React, { Component, Fragment } from 'react'

export default class Common extends Component {
    render() {
        return (
            <Fragment>

                <div className="top-part">
                这里是顶边栏
                </div>

                <div className='left-part'>
                    这里是左侧边栏
                </div>

                <div className='right-part'>
                    这里是右侧边栏
                </div>

        </Fragment>
        )
    }
}
```

```jsx
// /App.js
import React,{Component, Fragment} from 'react'

import {Route, Switch, Redirect} from 'react-router-dom'

import {routers} from './routers'
import {Common} from './components'

import './App.less'

export default class App extends Component {
    
    render() {
        return (
            <Fragment>
                <Common/>	
                <Switch>
                    {
                        routers.map(router => {
                            return <Route
                                key = {router.pathname}
                                path = {router.pathname}
                                exact = {router.exact}
                                render = {(routerProps) => {
                                    return <router.viewCompoment {...routerProps} />
                                
                                }}
                            />
                        })
                    }
                    <Redirect to='/404' />      {/* 搜寻不到路由时跳转404 */}
                    
                </Switch>

            </Fragment>
        )
    }
}
```

可以看到由于设计的逻辑是在App里渲染其他路由的页面，因此无论什么页面都一定会渲染app的公有内容，因此实现了公共部分在各个路由中的渲染

<img src="http://m.qpic.cn/psc?/V13Q7pAC4ZWKBC/ZOCeIbt3t.P7YdMG6dQVpARd82T.WDXVKVGjjviap.lrU0.fTlUblrQ5Cc.zCUGlKwiJp77DWfpnBEYugjSfYg!!/b&bo=fgMBAn4DAQIDCSw!&rf=viewer_4" style="margin:0">



----

#### 设计布局样式

现在这个布局很明显就是奔着flex布局走的，于是采用flex布局进行设计看看

**flex布局思路：**将`app.js`作为渲染，负责渲染顶、左、中、右的内容，那么就将渲染`app.js`所负责渲染的全部内容当成一个容器，而四个部分为四个项目在容器内排布就行

为了实现flex布局，发现之前的`app.js`内容设计有问题，于是重新将代码进行整理，总的思路不变，只是将四个部分拆分成四个组件`TopPart`、`LeftPart`、`MiddlePart`、`RightPart`

```jsx
// /scr/components/TopPart/index.js
import React, { Component } from 'react'

export default class TopPart extends Component {
    render() {
        return (

            <div>
                这里是顶边栏
            </div>
        )
    }
}
```

公共部分都差不多长一个样没什么好说的，将`App.js`之间的路由控制直接放在了`MiddlePart.js`里

```jsx
// /scr/components/Mide/index.js
import React, { Component } from 'react'

import {Route, Switch, Redirect} from 'react-router-dom'

import {routers} from '../../routers'

export default class MiddlePart extends Component {
    render() {
        return (
            <Switch>
                {
                    routers.map(router => {
                        return <Route
                            key = {router.pathname}
                            path = {router.pathname}
                            exact = {router.exact}
                            render = {(routerProps) => {
                                return <router.viewCompoment {...routerProps} />
                            
                            }}
                        />
                    })
                }
                <Redirect to='/404' />      {/* 搜寻不到路由时跳转404 */}
                
            </Switch>
        )
    }
}

```

然后`App.js`的代码就可以很干净，只负责渲染这些部分并负责这些部分的样式设计即可

发现组件无法直接定义className，那就用一个div元素将这些组件封在里面，设计div的排版即可决定这些组件的排版

```jsx
// /App.js
import React,{Component, Fragment} from 'react'

import {TopPart, LeftPart, MiddlePart ,RightPart} from './components'

import './App.less'

export default class App extends Component {
    
    render() {
        return (
            <div className='main-show'>

                <div className='top-part' >
                    <TopPart />
                </div>

                <div className='left-part'>
                    <LeftPart/>
                </div>
                
                <div className='middle-part'>
                    <MiddlePart/>
                </div>
                
                <div className='right-part'>
                    <RightPart/>
                </div>       
                
            </div>
        )
    }
}
```

div不怎么规范，换成语义化标签，稍微规范点...

```jsx
<div className='main-show'>

    <header className='top-part' >
        <TopPart />
    </header>

    <aside className='left-part'>
        <LeftPart/>
    </aside>

    <main className='middle-part'>
        <MiddlePart/>
    </main>

    <aside className='right-part'>
        <RightPart/>
    </aside>       

</div>
```

最终的效果和之前展示的是一样的，只是代码优化了不少

